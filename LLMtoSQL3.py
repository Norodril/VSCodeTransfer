import psycopg2  # lets Python connect to and talk with PostgreSQL
import ollama    # lets you talk to an LLM installed on your computer
from tabulate import tabulate #for nice table formatting
import csv #for exporting results to CSV files
import streamlit as st


# Open a connection to the PostgreSQL database
conn = psycopg2.connect(
    dbname="postgres",
    user="postgres",
    password="12345",
    host="localhost",
    port="5432"
)

cur = conn.cursor()  # Create a "cursor" to run queries

# Database schema description (for the LLM to understand structure)
schema = """ 
Tables:
Customers(CustomerID, Name, Email)
Orders(OrderID, CustomerID, ProductID, OrderDate)
Products(ProductID, ProductName, Price)
"""

# Function: convert a natural language question into an SQL query
def nl_to_sql(question):
    prompt = f"""
    You are a data assistant. Convert the following natural language question into a valid PostgreSQL query. Return ONLY the SQL code. Do not include explanations or anything else. Only use SELECT statements, do not delete or update data.
    {schema}

    Question: {question}
    SQL:
    """
    try:
        # Send the prompt to the LLM
        response = ollama.chat(model="llama3", messages=[{"role": "user", "content": prompt}])
        return response["message"]["content"].strip()
    except Exception as e: #If Ollama fails or something else goes wrong, the function prints an error and returns None
        print("Error while generating SQL:", e)
        return None

#Streamlit Part-------------------------------------------------------------------------------------------------------------
#Title of the app
st.title("Natural Language to SQL with Ollama and PostgreSQL")
#Creates a box where the user can type a natural language question
#whatever they type gets stored in the variable 'question'
question = st.text_input("Enter your question in plain English:")

if question: #only run question if the user typed something
    sql_query = nl_to_sql(question) #stores the SQL query generated by the LLM in 'sql_query'
    if sql_query: #if sql_query contains a non-empty string
        st.subheader("Generated SQL:") #section title
        st.code(sql_query, language="sql") #displays the SQL query in a code block with SQL syntax highlighting

        try:
            cur.execute(sql_query) #sends SQL to PostgreSQL
            results = cur.fetchall() #get results
            column_names = [desc[0] for desc in cur.description] #gets the column names
            st.subheader("Query Results:") #section title
            st.dataframe(results) #displays the results in a table format
            
            choice = st.radio("Do you want to export the results?", ("none", "csv", "table")) #radio buttons with the 3 options for exporting the results
            if choice == "csv": #if the user selects "csv"
                with open("query_results.csv", "w", newline="") as f: #opens or creates a new file called 'query_results.csv' and saves it as the variable f
                    writer = csv.writer(f) #creates a csv writer object- it will write to the file f
                    writer.writerow(column_names) #write headers
                    writer.writerows(results) #write the data
                st.success("Results saved to query_results.csv") #shows a success message in streamlit
            elif choice == "table": #if the user selects 'table'
                with open("query_results.txt", "w") as f: #opens or creates a new file called 'query_results.txt' and saves it as the variable f
                    f.write(tabulate(results, headers=column_names, tablefmt="grid")) #writes the results in a grid format table to the file
                st.success("Results saved to query_results.txt") #shows a success message in streamlit
            else: #if the user selects 'none'
                st.info("No export selected.") #no export selected message
        except psycopg2.Error as db_error: #If PostgreSQL returns an error, it is caught here and printed
            st.error(f"Database error: {db_error}")
        except Exception as e: #Catches any other unexpected error
            st.error(f"Unexpected error: {e}")



# Clean up database connection
cur.close() #closes the cursor
conn.close() #closes the connection to PostgreSQL
